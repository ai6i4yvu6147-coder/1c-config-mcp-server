# Проверка доработок MCP (оптимизация архитектуры)

## Запуск авто-проверки (локально)

Из корня проекта:

```bash
python scripts/verify_improvements.py
```

С тестовым списком проектов (если есть `test_projects.json` и база в `databases/`):

```bash
python scripts/verify_improvements.py --projects test_projects.json
```

---

## Чеклист проверки в MCP-клиенте (Cursor / другой клиент)

После подключения MCP выполните по шагам.

### 1. Новый инструмент `list_active_databases`

- Вызвать **list_active_databases** без параметров.
- **Ожидание:** в ответе список проектов и для каждого — список баз (имя, тип base/extension).

### 2. Обязательный `project_filter`

- Вызвать **search_code** с параметром `query` = "Запрос", **без** `project_filter`.
- **Ожидание:** ошибка с требованием указать project_filter или использовать list_active_databases.

- Вызвать **find_object** с `name` = "Справочник", **без** `project_filter`.
- **Ожидание:** та же логика — ошибка про project_filter.

### 3. Поиск с указанием проекта

- Вызвать **list_active_databases** → запомнить имя проекта (например, "ТГ" или из вашего projects.json).
- Вызвать **search_code** с `query` = "Запрос" и `project_filter` = имя проекта.
- **Ожидание:** ответ по коду (или пустой результат), без ошибки про project_filter.

### 4. Процедуры и контекст выполнения

- Вызвать **get_module_procedures** с `object_name` = любой объект с модулем (например, константа или справочник), `module_type` = "Module", `project_filter` = ваш проект.
- **Ожидание:** в списке процедур/функций у каждой есть поле контекста: **Client**, **Server** или **ClientOrServer** (если директива над процедурой есть).

### 5. Код процедуры с директивой

- Вызвать **get_procedure_code** для любой процедуры из модуля формы или объекта, у которой над объявлением стоит директива (например, `&НаКлиенте` или `&НаСервере`).
- **Ожидание:** в возвращённом коде **первой строкой** идёт строка директивы (например, `&НаКлиенте`), затем объявление процедуры/функции.

### 6. Тип формы и элементы

- Вызвать **find_form** с `project_filter` и при необходимости `object_name` / `form_name`.
- **Ожидание:** в описании каждой формы есть **form_kind**: List, Choice или Element.

- Вызвать **get_form_structure** для конкретной формы.
- **Ожидание:** в форме есть поле **form_kind**; у элементов интерфейса — поля **visible** и **enabled** (без полного properties_json).

### 7. Поиск по свойствам элементов

- Вызвать **search_form_properties** с `property_name` = "Visible", `property_value` = "false" (или 0), `project_filter` = проект.
- **Ожидание:** список элементов с Visible = 0 (или false).

- Вызвать **search_form_properties** с `property_name` = "ReadOnly".
- **Ожидание:** ошибка о том, что поддерживаются только Visible и Enabled.

### 8. Расширения — принадлежность (object_belonging)

Если в списке баз есть **расширение** (extension):

- Вызвать **find_object** или **list_objects** с `project_filter` по проекту, где есть расширение.
- **Ожидание:** у объектов из базы-расширения в ответе есть поле **object_belonging**: "Own" или "Adopted" (если парсер и БД это заполняют).

---

## Директивы компиляции (напоминание)

В коде процедур распознаются только **4 директивы** модулей форм:

- `&НаКлиенте` / `&AtClient`
- `&НаСервере` / `&AtServer`
- `&НаСервереБезКонтекста` / `&AtServerNoContext`
- `&НаКлиентеНаСервереБезКонтекста` / `&AtClientAtServerNoContext`

`ПослеЗаписиНаСервере` и т.п. — это имена методов, а не директивы; в шаблоне поиска директив они не используются.
